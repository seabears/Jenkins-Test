/**********************************************************************************************************************
 * \file Cpu0_Main.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation coveRED_LED by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/
#include "Ifx_Types.h"
#include "IfxCpu.h"
#include "IfxScuWdt.h"

// My include
#include <asclin_driver/asclin.h>
#include <stm_driver/stm.h>
#include <mq135_driver/mq135.h>
#include <dht22_driver/dht22.h>
#include <mhz19b_driver/mhz19b.h>
#include <PWM_driver/PWM.h>
#include <hvac_ctl_driver/hvac_ctl.h>
#include <can_driver/can.h>
#include"main.h"


#include "IfxPort.h"
#include "IfxPort_PinMap.h"


// Task scheduling related
void AppScheduling(void);
void AppTask1000ms(void);

// Global variables
IfxCpu_syncEvent g_cpuSyncEvent = 0;    // CPU sync event
TestCnt stTestCnt;                      // Test counter for scheduling
Hvac g_hvac;                            // HVAC control data
Sensor_Data g_data;                     // HVAC sensor data

/* 글로벌 핸들 */
IfxMultican_Can        g_can;         // CAN 모듈 핸들
IfxMultican_Can_Node   g_canNode;     // CAN 노드 핸들
IfxMultican_Can_MsgObj g_txMsgObj;    // 송신 메시지 오브젝트
IfxMultican_Can_MsgObj g_rxMsgObj;    // 수신 메시지 오브젝트

uint8 g_sleep = 0;
/* 송신 메시지 */
IfxMultican_Message g_txMsg;
/* 수신 메시지 */
IfxMultican_Message g_rxMsg;

IfxMultican_Status g_status;  // CAN 상태



void initSleepMode(void)
{
    /* Clear ENDINIT protection */
    IfxScuWdt_clearCpuEndinit(IfxScuWdt_getCpuWatchdogPassword());

    /* Set CPU0 as the master CPU for Sleep Request */
    SCU_PMSWCR1.B.CPUSEL = 0x1;  // CPU0 선택

    /* Set ENDINIT protection */
    IfxScuWdt_setCpuEndinit(IfxScuWdt_getCpuWatchdogPassword());
}

void enter_sleep_mode(void)
{
    if (g_sleep == 0)
    {
        //print("잠든다!!\n\r");
        for(volatile uint32 i = 0; i < 1000000; i++); // Delay : can.c에서 "Sleep Mode" 출력 대기
        g_sleep = 1;

        IfxScuWdt_clearCpuEndinit(IfxScuWdt_getCpuWatchdogPassword());
        SCU_PMCSR0.B.REQSLP = 0x2;  // Request CPU0 to enter sleep mode
        IfxScuWdt_setCpuEndinit(IfxScuWdt_getCpuWatchdogPassword());
    }
}

void exit_sleep_mode()
{
    if (g_sleep == 1)
    {
        g_sleep = 0;
    }
}

// void initGPIO(void)
// {
//     // GPIO 초기화
//     IfxPort_setPinModeOutput(RED_LED.port, RED_LED.pinIndex, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
//     IfxPort_setPinLow(RED_LED.port, RED_LED.pinIndex);  // 초기값 HIGH

//     IfxPort_setPinModeOutput(YELLOW_LED.port, YELLOW_LED.pinIndex, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
//     IfxPort_setPinLow(YELLOW_LED.port, YELLOW_LED.pinIndex);  // 초기값 HIGH

//     IfxPort_setPinModeOutput(GREEN_LED.port, GREEN_LED.pinIndex, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
//     IfxPort_setPinLow(GREEN_LED.port, GREEN_LED.pinIndex);  // 초기값 HIGH
// }
void core0_main(void)
{
    IfxCpu_enableInterrupts();
    
    /* !!WATCHDOG0 AND SAFETY WATCHDOG ARE DISABLED HERE!!
     * Enable the watchdogs and service them periodically if it is requiRED_LED
     */
    IfxScuWdt_disableCpuWatchdog(IfxScuWdt_getCpuWatchdogPassword());
    IfxScuWdt_disableSafetyWatchdog(IfxScuWdt_getSafetyWatchdogPassword());
    
    /* Wait for CPU sync event */
    IfxCpu_emitEvent(&g_cpuSyncEvent);
    IfxCpu_waitEvent(&g_cpuSyncEvent, 1);


    // Initialize the HVAC system
    sensor_init(&g_data);   // Init 센서 데이터
    hvac_init(&g_hvac);     // Init HVAC

    initShellInterface();   // Init Debug
    Driver_Stm_Init();      // Init Scheuduling
    Driver_MQ135_Init();    // Init MQ135 ADC
    Driver_MHZ19B_Init();   // Init MH-Z19B ASCLIN
    initFanTomPwm();        // Init Fan PWM
    initServoPwm();         // Init Servo PWM
    initCan();              // Init CAN
    initSleepMode();        // Init Sleep Mode
    //initGPIO();             // Init GPIO

    //enter_sleep_mode();       // Sleep 모드 진입  // TODO
    //sendCanMessage();   // CAN 송신 : 빠져나왔다!!

    while(1)
    {
        AppScheduling();
        canReceiveLoop(&g_hvac);

    }
}

void AppTask1000ms(void)
{
    stTestCnt.u32nuCnt1000ms++;
    
    print("---------------------------\n\r");

    // 1. MQ135
    uint16 mq135_adcval = 0;
    mq135_adcval = Driver_Adc0_DataObtain();   // mq135 val평소 1600
    Driver_Adc0_ConvStart();

    print(MAGENTA"< MQ135 >\n\r"RESET);
    print("adcval      : ");
    print(CYAN"%d\n\r"RESET, mq135_adcval);

    // 2. DHT22
    DHT22_Data dht22_data;
    if(stTestCnt.u32nuCnt1000ms % 2){        // DHT22 Period = 2s
        int result = DHT22_process(&dht22_data);  // DHT22 데이터 읽기
        if(!result){
            print(MAGENTA"< DHT22 > \n\r"RESET);
            print("temperature : ");
            print(CYAN"%.1lf °C\n\r"RESET, (double)dht22_data.temperature/10);
            print("humidity    : ");
            print(CYAN"%.1lf %%\n\r"RESET, (double)dht22_data.humidity/10);
        }
        else{
            print("DHT22 Error : %d\n\r", result);
        }
    }

    // 3. MH-Z19B
    uint16 mhz19b_value = 0;
    int mhz19b_ret = MHZ19B_requestCO2(&mhz19b_value);
    if(!mhz19b_ret){
        print(MAGENTA"< MH-Z19B >\n\r"RESET);
        print("CO2         : ");
        print(CYAN"%d ppm\n\r"RESET, mhz19b_value);
    }
    else{
        print("MH-Z19B Error, %d\n\r", mhz19b_value);
    }

    // 4. Hvac Control
    g_data.ext_air = mq135_adcval;         // 외부 공기질
    g_data.int_co2 = mhz19b_value;        // 내부 CO2 농도
    g_data.int_temperature = (double)dht22_data.temperature/10; // 내부 온도
    g_data.int_humidity = (double)dht22_data.humidity/10;     // 내부 습도
    int hvac_ret = havc_control(&g_hvac, g_data);  // 센서 데이터 바탕으로 팬 제어 함수 호출

    if(hvac_ret == 0){
        print(MAGENTA"< HVAC Automatic Control >\n\r"RESET);
        print("HVAC Mode   : ");
        if(g_hvac.mode == EXT_MODE)         print(CYAN"External Mode(%d)\n\r"RESET, g_hvac.mode);
        else if(g_hvac.mode == INT_MODE)    print(CYAN"Internal Mode(%d)\n\r"RESET, g_hvac.mode);
        //print(CYAN"%d\n\r"RESET, g_hvac.mode);
        print("HVAC Speed  : ");
        print(CYAN"%d\n\r"RESET, g_hvac.speed);
    }
    else if(hvac_ret == 1){
        print(MAGENTA"< HVAC "YELLOW"Manual Control >\r\n"RESET);
        print("HVAC Mode   : ");
        if(g_hvac.mode == EXT_MODE)         print(CYAN"External Mode(%d)\n\r"RESET, g_hvac.mode);
        else if(g_hvac.mode == INT_MODE)    print(CYAN"Internal Mode(%d)\n\r"RESET, g_hvac.mode);
        //print(CYAN"%d\n\r"RESET, g_hvac.mode);
        print("HVAC Speed  : ");
        print(CYAN"%d\n\r"RESET, g_hvac.speed);
    }
    else{
        print("HVAC Error : %dn\r", hvac_ret);
    }

    // 5. CAN 송신 9, 10초
    if(stTestCnt.u32nuCnt1000ms % 5 == 0) { // 9초에 한번
        // 온도, 습도 데이터 송신
        g_txMsg.id = 0x21;
        g_txMsg.lengthCode = 8;
        g_txMsg.data[0] = (uint32)(g_data.int_temperature * 10); // 온도
        g_txMsg.data[1] = (uint32)(g_data.int_humidity * 10);    // 습도
        g_status = sendCanMessage();  // 메시지 전송
        // do {
        //     int cnt = 0;
        //     cnt++;
        //     g_status = sendCanMessage();  // 메시지 전송
        //     if(cnt > 3) {
        //         print("CAN 송신 실패 ID : %d\r\n", g_txMsg.id);
        //         //break;
        //     }
        // } while (g_status != IfxMultican_Status_ok);  // 성공적으로 전송되었을 때까지 반복

        //for(volatile int i=0;i<100000;i++);  // 대기

        
        // do {
        //     int cnt = 0;
        //     cnt++;
        //     g_status = sendCanMessage();  // 메시지 전송
        //     if(cnt > 3) {
        //         print("CAN 송신 실패 ID : %d\r\n", g_txMsg.id);
        //         break;
        //     }
        // } while (g_status != IfxMultican_Status_ok);  // 성공적으로 전송되었을 때까지 반복
    }
    else if(stTestCnt.u32nuCnt1000ms % 6 == 0) {   // 10초에 한번
        g_txMsg.id = 0x20;
        g_txMsg.lengthCode = 8;
        g_txMsg.data[0] = ((uint32)(g_data.ext_air) << 16) | (uint32)(g_data.int_co2);  // 외부 공기질, 내부 CO2 농도
        g_txMsg.data[1] = ((uint32)(g_hvac.mode) << 16) | (uint32)(g_hvac.speed);       // HVAC 모드, 팬 속도
        g_status = sendCanMessage();  // 메시지 전송

    }
}

void AppScheduling(void)
{
    if(stSchedulingInfo.u8nuScheduling1000msFlag == 1u)
    {
        stSchedulingInfo.u8nuScheduling1000msFlag = 0u;
        AppTask1000ms();
    }
}

